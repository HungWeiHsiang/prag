#include "game.h"
#include "gameobject.h"
#include "texturemanager.h"
#include "map.h"
#include <cstdlib>
using namespace std;
int gx;
int gy;
int px;
int py;
int cx;
int cy;
int gover=0;
int cch=0;
static int cntt=0;
int ggov()
{
	if(gover!=1)
	{
		return 1;	
	}
	return 0;
}
GameObject::GameObject(const char* texturesheet,int x,int y)
{
	objTexture=TextureManager::LoadTexture(texturesheet);
	xpos=x;
	ypos=y;
}
void GameObject::Update()
{
	int lvl1[20][25]=
	{
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0},
	{0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0},
	{0,1,1,1,0,2,2,0,2,2,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0},
	{0,1,0,0,0,2,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0},
	{0,1,1,1,0,2,2,0,2,2,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,0,0,2,2,2,2,2,0,0,0,1,0,0,1,0},
	{0,1,0,0,1,0,0,0,1,1,1,1,2,0,0,0,2,1,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,0,1,1,0,1,1,1,0},
	{0,1,0,0,1,0,1,0,1,1,1,1,2,0,0,1,0,0,0,1,0,0,0,1,0},
	{0,1,1,0,1,0,1,0,1,0,0,0,2,0,1,1,1,0,1,1,0,1,1,1,0},
	{0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,2,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,2,0,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,2,1,1,1,1,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,2,0,0,0,1,0,1,0},
	{0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	};
	if(cntt>=1000&&gover==0)
	{
		lvl1[3][11]=1;
		lvl1[3][13]=1;
		lvl1[16][11]=1;
		lvl1[16][13]=1;
	}
	int t=xpos;
	int u=ypos;
	while(gover==0&&t==xpos&&u==ypos)
	{
			det=5;
			int tt=rand()%10+3;
			int dn=tt%4;
			switch(dn)
			{
			case 0:
				if(i!=2&&lvl1[ypos/32][xpos/32+1]!=0&&lvl1[(ypos+31)/32][xpos/32+1]!=0)
				{
					xpos=xpos+4;
					i=0;
					break;
				}
			case 1:
				if(i!=3&&lvl1[ypos/32+1][xpos/32]!=0&&lvl1[ypos/32+1][(xpos+31)/32]!=0)
				{
					ypos=ypos+4;
					i=1;
					break;
				}
			case 2:
				if(i!=0&&lvl1[ypos/32][(xpos-1)/32]!=0&&lvl1[(ypos+31)/32][(xpos-1)/32]!=0)
				{
					xpos=xpos-4;
					i=2;
					break;
				}
			case 3:
				if(i!=1&&lvl1[(ypos-1)/32][xpos/32]!=0&&lvl1[(ypos-1)/32][(xpos+31)/32]!=0)
				{
					ypos=ypos-4;
					i=3;
					break;
				}
			default:
				{
					break;	
				}		
			}		
	}
	det=0;
	gx=xpos;
	gy=ypos;
	srcRect.h=32;
	srcRect.w=32;
	srcRect.x=0;
	srcRect.y=0;
	
	destRect.x=xpos;
	destRect.y=ypos;
	destRect.w=srcRect.w;
	destRect.h=srcRect.h;
	if(t<800)
	{
		dead();
	}
}
void GameObject::dead()
{
	if(gx-px<32&&px-gx<32&&gy-py<32&&py-gy<32)
	{
		gameover();
	}
}
void GameObject::gameover()
{
	if(gover==0)
	{
		cout<<"Gameover!"<<endl;
	}
	gover=1;
}
void GameObject::Render()
{
	SDL_RenderCopy(Game::renderer,objTexture,&srcRect,&destRect);
}

Ghost::Ghost(const char* texturesheet,int x,int y)
{
	objTexture=TextureManager::LoadTexture(texturesheet);
	xpos=x;
	ypos=y;
}
void Ghost::Update()
{
	int lvl1[20][25]=
	{
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0},
	{0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0},
	{0,1,1,1,0,2,2,0,2,2,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0},
	{0,1,0,0,0,2,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0},
	{0,1,1,1,0,2,2,0,2,2,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,0,0,2,2,2,2,2,0,0,0,1,0,0,1,0},
	{0,1,0,0,1,0,0,0,1,1,1,1,2,0,0,0,2,1,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,0,1,1,0,1,1,1,0},
	{0,1,0,0,1,0,1,0,1,1,1,1,2,0,0,1,0,0,0,1,0,0,0,1,0},
	{0,1,1,0,1,0,1,0,1,0,0,0,2,0,1,1,1,0,1,1,0,1,1,1,0},
	{0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,2,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,2,0,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,2,1,1,1,1,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,2,0,0,0,1,0,1,0},
	{0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	};
	if(cntt<10000)
	{
		cntt=cntt+1;
	}
	if(cntt>=1000&&gover==0)
	{
		lvl1[3][11]=1;
		lvl1[3][13]=1;
		lvl1[16][11]=1;
		lvl1[16][13]=1;
	}
	int t=xpos;
	int u=ypos;
	while(cntt>=1000&&gover==0&&t==xpos&&u==ypos)
	{
		
		int tt=rand()%10+3;
		int dn=tt%4;
		switch(dn)
		{
		case 0:
			if(i!=2&&lvl1[ypos/32][xpos/32+1]!=0&&lvl1[(ypos+31)/32][xpos/32+1]!=0)
			{
				xpos=xpos+8;
				i=0;
				break;
			}
		case 1:
			if(i!=3&&lvl1[ypos/32+1][xpos/32]!=0&&lvl1[ypos/32+1][(xpos+31)/32]!=0)
			{
				ypos=ypos+8;
				i=1;
				break;
			}
		case 2:
			if(i!=0&&lvl1[ypos/32][(xpos-1)/32]!=0&&lvl1[(ypos+31)/32][(xpos-1)/32]!=0)
			{
				xpos=xpos-8;
				i=2;
				break;
			}
		case 3:
			if(i!=1&&lvl1[(ypos-1)/32][xpos/32]!=0&&lvl1[(ypos-1)/32][(xpos+31)/32]!=0)
			{
				ypos=ypos-8;
				i=3;
				break;
			}
		default:
			{
				break;	
			}		
		}
			
	}
	gx=xpos;
	gy=ypos;
	srcRect.h=32;
	srcRect.w=32;
	srcRect.x=0;
	srcRect.y=0;
	
	destRect.x=xpos;
	destRect.y=ypos;
	destRect.w=srcRect.w;
	destRect.h=srcRect.h;
	if(t<800)
	{
		dead();
	}
}
void Ghost::dead()
{
	if(gx-px<32&&px-gx<32&&gy-py<32&&py-gy<32)
	{
		gameover();
	}
}
void Ghost::gameover()
{
	if(gover==0)
	{
		cout<<"Gameover!"<<endl;
	}
	gover=1;
}
void Ghost::Render()
{
	SDL_RenderCopy(Game::renderer,objTexture,&srcRect,&destRect);
}

Player::Player(const char* texturesheet,int x,int y)
{
	objTexture=TextureManager::LoadTexture(texturesheet);
	xpo=x;
	ypo=y;
}
void Player::Update()
{
	int lvl1[20][25]=
	{
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0},
	{0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0},
	{0,1,1,1,0,2,2,0,2,2,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0},
	{0,1,0,0,0,2,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0},
	{0,1,1,1,0,2,2,0,2,2,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,0,0,2,2,2,2,2,0,0,0,1,0,0,1,0},
	{0,1,0,0,1,0,0,0,1,1,1,1,2,0,0,0,2,1,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,0,1,1,0,1,1,1,0},
	{0,1,0,0,1,0,1,0,1,1,1,1,2,0,0,1,0,0,0,1,0,0,0,1,0},
	{0,1,1,0,1,0,1,0,1,0,0,0,2,0,1,1,1,0,1,1,0,1,1,1,0},
	{0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,2,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,2,0,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,2,1,1,1,1,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,2,0,0,0,1,0,1,0},
	{0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	};
	if(cntt>=1000&&gover==0)
	{
		lvl1[3][11]=1;
		lvl1[3][13]=1;
		lvl1[16][11]=1;
		lvl1[16][13]=1;
	}
	int t=xpo;
	int u=ypo;
	while(gover==0&&t==xpo&&u==ypo)
	{
		int tt=rand()%10+3;
		int dn=tt%4;
		switch(dn)
		{
		case 0:
			if(j!=2&&lvl1[ypo/32][xpo/32+1]!=0&&lvl1[(ypo+31)/32][xpo/32+1]!=0)
			{
				xpo=xpo+8;
				j=0;
				break;
			}
		case 1:
			if(j!=3&&lvl1[ypo/32+1][xpo/32]!=0&&lvl1[ypo/32+1][(xpo+31)/32]!=0)
			{
				ypo=ypo+8;
				j=1;
				break;
			}
		case 2:
			if(j!=0&&lvl1[ypo/32][(xpo-1)/32]!=0&&lvl1[(ypo+31)/32][(xpo-1)/32]!=0)
			{
				xpo=xpo-8;
				j=2;
				break;
			}
		case 3:
			if(j!=1&&lvl1[(ypo-1)/32][xpo/32]!=0&&lvl1[(ypo-1)/32][(xpo+31)/32]!=0)
			{
				ypo=ypo-8;
				j=3;
				break;
			}
		default:
			{
				break;	
			}		
		}	
	}
	px=xpo;
	py=ypo;
	srcRect.h=32;
	srcRect.w=32;
	srcRect.x=0;
	srcRect.y=0;
	
	destRect.x=xpo;
	destRect.y=ypo;
	destRect.w=srcRect.w;
	destRect.h=srcRect.h;
	
}

void Player::Render()
{
	SDL_RenderCopy(Game::renderer,objTexture,&srcRect,&destRect);
}

Chi::Chi(const char* texturesheet,int x,int y)
{
	objTexture=TextureManager::LoadTexture(texturesheet);
	xpo=x;
	ypo=y;
}
void Chi::Update()
{
	int lvl1[20][25]=
	{
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0},
	{0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0},
	{0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0},
	{0,1,1,1,0,2,2,0,2,2,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0},
	{0,1,0,0,0,2,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,0},
	{0,1,1,1,0,2,2,0,2,2,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0},
	{0,1,0,1,1,0,2,2,2,0,0,0,2,2,2,2,2,0,0,0,1,0,0,1,0},
	{0,1,0,0,1,0,0,0,1,1,1,1,2,0,0,0,2,1,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,0,1,1,0,1,1,1,0},
	{0,1,0,0,1,0,1,0,1,1,1,1,2,0,0,1,0,0,0,1,0,0,0,1,0},
	{0,1,1,0,1,0,1,0,1,0,0,0,2,0,1,1,1,0,1,1,0,1,1,1,0},
	{0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,2,1,0,1,1,0,1,0},
	{0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,2,0,0,1,0,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,2,1,1,1,1,0,1,0},
	{0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,2,0,0,0,1,0,1,0},
	{0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
	};
	if(cntt>=1000&&gover==0)
	{
		lvl1[3][11]=1;
		lvl1[3][13]=1;
		lvl1[16][11]=1;
		lvl1[16][13]=1;
	}
	int t=xpo;
	int u=ypo;
	while(gover==0&&u<640&&t==xpo&&u==ypo)
	{
			det=5;
			int tt=rand()%10+3;
			int dn=tt%4;
			switch(dn)
			{
			case 0:
				if(j!=2&&lvl1[ypo/32][xpo/32+1]!=0&&lvl1[(ypo+31)/32][xpo/32+1]!=0)
				{	
					xpo=xpo+4;
					j=0;
					break;
				}
			case 1:
				if(j!=3&&lvl1[ypo/32+1][xpo/32]!=0&&lvl1[ypo/32+1][(xpo+31)/32]!=0)
				{
					ypo=ypo+4;
					j=1;
					break;
				}
			case 2:
				if(j!=0&&lvl1[ypo/32][(xpo-1)/32]!=0&&lvl1[(ypo+31)/32][(xpo-1)/32]!=0)
				{
					xpo=xpo-4;
					j=2;
					break;
				}	
			case 3:
				if(j!=1&&lvl1[(ypo-1)/32][xpo/32]!=0&&lvl1[(ypo-1)/32][(xpo+31)/32]!=0)
				{
					ypo=ypo-4;
					j=3;
					break;
				}
			default:
				{
					break;	
				}		
			}	
			
	}
	det=0;
	cx=xpo;
	cy=ypo;
	srcRect.h=32;
	srcRect.w=32;
	srcRect.x=0;
	srcRect.y=0;
	
	destRect.x=xpo;
	destRect.y=ypo;
	destRect.w=srcRect.w;
	destRect.h=srcRect.h;
	if(u<640)
	{
		ced();
	}
}
void Chi::ced()
{
	if(cx-px<32&&px-cx<32&&cy-py<32&&py-cy<32)
	{
		xpo=0+32*cch;
		ypo=640;
		cch=cch+1;
		if(cch==4)
		{
			finish();
		}
	}
}
void Chi::finish()
{
	if(gover==0)
	{
		cout<<"Victory!"<<endl;
	}
	gover=1;
}
void Chi::Render()
{
	SDL_RenderCopy(Game::renderer,objTexture,&srcRect,&destRect);
}
